---
title: "シャーディング経験者に向けたSpannerのコンセプト解説"
emoji: "🔧"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["spanner", "gcp"]
published: false
publication_name: "google_cloud_jp"
---
## この記事の目的

リレーショナルデータベース（以下、RDBMS）を大規模に利用されるときの構成手法として、データベースシャーディング（Database sharding）という方法があります。オンラインゲームやSaaSなどアクセス頻度が高く、個別のユーザーの操作ごとの更新量が大きい用途などでデータベースの書き込み性の限界への回避策として多くの場面で利用されている手法です。

この手法について簡単に触れた後、この手法の経験者がSpannerを使う場合にシャーディングでの概念をどのようにSpannerに対応できるか解説します。

## シャーディングの構成

[シャーディング](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%A3%E3%83%BC%E3%83%89_(%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%83%BB%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3))は通常水平分割で実現されます。つまり1つのテーブルの行を複数の異なる物理データベースに配置します。このとき、どのカラムを基準にして分割するかを決めますが、このようなカラムをシャーディングキーと呼びます。よくあるケースではユーザーテーブルをシャーディング対象としたとき、ユーザー IDといったユーザーを一意に特定できるカラムを使って分散させます。マルチテナントのSaaSなどではテナントIDをシャーディングキーに使う場合もあるでしょう。

さらにあるレコードをどのシャードに格納するかを決める方法として、ハッシュ関数を適用してその結果を使う方式や、ユーザー IDとシャードの対応表を持つ方式などがあります。このドキュメントでは前者をハッシュ方式、後者を対応表方式と呼ぶことにします。
ハッシュ方式はロジック的にシャードが決定できるというメリットがありますが、運用開始をしてからの増設やシャーディングのやり直しがやや煩雑となります。
対応表方式は対応表を持つデータベースというコンポーネントが増えるものの、シャード増設が容易であると言ったメリットがあります。

![対応表方式でのシャーディング構成の図](/images/shard_concept.png)

対応表方式では実データへアクセスする前に対応表を一度引いてからアクセス先のシャードを確定し、実際のシャードにアクセスする動きとなります。

## シャーディングのメリット

### 書き込み性能上限の引き上げ

読み込み性能については読み取りレプリカを作ることで性能を引き上げる事が可能ですが、書き込み性能に関してはインスタンスサイズのスケールアップを行う必要がありました。シャーディングは書き込み先を複数の物理データベースに分散させることができるので、書き込み性能に関してもスケールアウトすることが可能です。

対応表方式ではアクセス毎にこの対応表を引くことになるため、それなりの性能が必要になります。幸い対応表は通常、頻繁に書き換えられることはないため、長いTTLで効率よくキャッシュすることが可能です。対応表のデータ構造は単純であるためmemcachedやRedisなどに書いて置くことも可能です。

## シャーディングのデメリット

### アプリケーション側の複雑さ

シャーディングされたデータベースへアクセスする部分でシャード決定する機構(シャードリゾルバ)が必要となります。一度書いてしまえば流用が可能ですが、バッチなど一部のアプリケーションが異なる言語で書かれている場合にはそれらの間で挙動を完全に一致させておくことが重要です。

対応表方式では毎回対応表へアクセスを行うとシャード全体と同じぐらいの高頻度のアクセスを受ける事となるため、前述の通りキャッシュすることが有効です。

### 構成管理の煩雑さ

一般的に各シャードは同一のテーブル構成で運用されます。そのため、シャーディング対象のデータベースに新しいテーブルやインデックスを追加するときに各シャードにDDLを漏れなく実行する必要があります。

### キャパシティ管理

各シャードの負荷が均一になっていると運用管理が楽ですが、現実問題としてはそのシャードに含まれるユーザー数を均一にしたとしてもサービスへのアクティビティが均一にならない（新規と初期ユーザーでアクティビティが異なるなど）こともあり個別で性能のキャパシティ管理が必要となります。

### シャードの増設・削除

サービス開始当初のシャード数では性能やストレージ容量が不足してきた場合には増設が必要になります。対応表方式では新規ユーザーを新シャードに登録するなどの工夫で増設することが可能でしょう。一方でハッシュ方式ではハッシュ関数にもよりますが、既存のユーザーのシャード移動が必要になる場合があります。これはかなり煩雑な対応が必要で、更新が行われないメンテナンス時間を設けてその間に実施するなどの工夫が必要です。

シャードの削除については廃止シャード上のユーザーのシャード間での移動が必要となるため、実際には廃止は行わず各シャードのスケールダウンで済ませる事が多いかもしれません。その場合、サービス全体のアクティビティが落ちてきたとしてもシャード数は維持する必要があります。

### シャードをまたいだ処理

シャーディングを導入した場合、複数のシャードが関連する処理は慎重に実装する必要があります。たとえば、ゲームであるユーザー（`UserID` AAAA、シャード1に所属）から別のユーザー（`UserID` BBBB、シャード3に所属）へアイテム（`ItemId` XXXX）を受け渡すような処理を考えます。この場合、

元ユーザー(AAAA)のシャード1に対して

```sql
DELETE FROM Items WHERE UserID=AAAA AND ItemId=XXXX
```

贈り先ユーザー(BBBB)のシャード3に対して

```sql
INSERT INTO Items (UserID, ItemId, ... ) VALUES (BBBB, XXXX, ...)
```

というDMLを発行することになるでしょう。各ユーザーは異なるシャード、つまり異なるデータベースに格納されている可能性があります。そのため、これらのDMLは2つの独立したトランザクションで発行されることになります。トランザクションがいずれも成功あるいは失敗した場合は問題ありませんが、一方のみが成功した場合にはアイテムがロストしたり増殖してしまいます。本来はこのような事態を避けるために[分散トランザクションの仕組み](https://dev.mysql.com/doc/refman/8.0/ja/xa.html)を使ってデータベース間で協調させる必要があります。

更新ではない場合でも、たとえばシャードをまたいだ検索処理を行いたい場合には全シャードをくまなく検索する必要があります。先の例のようにゲームのアイテムを想定すると、どのユーザーが所有しているか分からない特定のアイテムを全ユーザー検索したい場合などです。

## Spannerの自動シャーディング

Spannerは自動シャーディングという仕組みがあります。これは文字通り水平分割を自動的に行う機能です。シャーディングで使っていた分割の基準となるシャーディングキーとしては、プライマリキーを使います。

Spannerではテーブルはプライマリキーの辞書順でレイアウトされます。このレイアウトに対して、負荷の状況に応じて自動的にスプリットという単位へと分割を行います。個々のスプリットを異なるサーバーへ割り当てることで負荷を平準化とスケールを可能としています。

![Spannerでのシャードのイメージ](/images/spanner_shard.png)

スプリットは細かくなりすぎても効率が良くないため、負荷の低い状態が継続した場合には統合される場合もあります。

### インターリーブテーブル

シャーディング構成では分割の基準となるテーブル以外も各シャードに配置することがあります。
引き続きゲームでの例を考えます。ユーザーの基本的なデータを管理するテーブル（`Users`）が分割の基準になるでしょう。このテーブルは当然各シャードに分散配置します。また、各ユーザーはアイテム(`Items`)や魔法(Spells)を複数持っている場合、これらのテーブルを各シャードに配置することになります。
これはユーザー情報とその所有アイテム情報をJOINするなどして一度にアクセスするときに効率的にアクセスできるようにするためです。

![シャード構成でのテーブルの配置](/images/shard_tables.png)

このようなテーブル構成をSpannerで実現する場合、[インターリーブされたテーブル](https://cloud.google.com/spanner/docs/schema-and-data-model?hl=ja#create-interleaved-tables)を使うと似たような物理レイアウト構成が可能です。DDLは以下のような構成になるでしょう。

```sql
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(128),
  Job INT64,
  GuildId INT64,
) PRIMARY KEY(UserId);
```

```sql
CREATE TABLE Items (
  UserId INT64 NOT NULL,
  ItemId STRING(128),
  ItemName STRING(128),
  Quantity INT64,
  UsageCount INT64,
) PRIMARY KEY(UserId, ItemId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
  ```

```sql
CREATE TABLE Spells (
  UserId INT64 NOT NULL,
  SpellId STRING(128),
  SpellName STRING(128),
) PRIMARY KEY(UserId, SpellId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
  ```

  プライマリキーが通常のシャーディング構成とはちょっと違うかもしれません。`ItemId`が単体で一意である場合、これだけをプライマリキーにする場合もありますが、インターリーブテーブルでは`UserId`と`ItemId`の[複合プライマリキーにする必要](https://cloud.google.com/spanner/docs/schema-and-data-model?hl=ja#primary-keys)があります。ちょっと迂遠に感じるかもしれませんが、シャーディング構成でもシャーディングキー(この場合、`UserId`)が不明だった場合には格納しているシャードが決定できないためアクセス時には常に`UserId`を必要とするので、インターリーブでこれを前につけること自体は違和感はないと思います。

この例ではUsersテーブルに対して、ItemsテーブルとSpellsテーブルをインターリーブしています。インターリーブ(Interleave)とは間に綴じ込むという意味です。その名前の通り、Usersテーブルのレコードの間に対応する2つのテーブルを配置します。これによってユーザーのデータとその所有アイテムと魔法のアイテムがまとまっているため、JOINなどで同時にアクセスするときも効率が良いです。

![インターリーブでの物理レイアウト](/images/spanner_interleave_layout.png)

### インターリーブインデックス

Spannerではセカンダリインデックスについてもインターリーブが可能です。
例えば、`Items`の`Quantity`カラムにインデックスを作る場合を考えます。DDLとしては以下のようになります。

```sql
CREATE INDEX ItemQuantity ON Items(UserId, Quantity), INTERLEAVE IN Users;
```

インターリーブテーブルと同じく、`UserId`が先頭につきますがこれはシャーディング構成でのシャード決定に必要な理由と同様です。`Items`テーブルへのインデックスですがインターリーブ先としては`Users`テーブルであることに注意してください。

インデックスをインターリーブするメリットはテーブルと同様に関連するレコードと連続配置されるので効率よくアクセスすることが可能です。
シャーディング構成で各シャードに作成したセカンダリインデックスは多くの場合でインターリーブインデックスに読み替えが可能でしょう。

### セカンダリインデックス

Spannerではインターリーブでは**ない**インデックスを作ることも可能です。このようなセカンダリインデックスに特に名前はついていませんがテーブル全体へのインデックスですので、ここではグローバルインデックスと呼ぶことにします。グローバルインデックスがあればシャード構成でのシャードをまたぐようなテーブル全体へも効率的に検索が可能です。

一方で、テーブル全体へのインデックスであるためインデックスの対象カラムへの更新があったときはグローバルインデックスも同時に更新が発生します。インデックス対象カラムが[単調増加・減少する内容だった場合には特定の部分に更新が集中する](https://cloud.google.com/spanner/docs/schema-design?hl=ja#creating-indexes)ことになります。このようなグローバルインデックスを作る場合、インターリーブが可能か、可能でない場合は何らかの方法で書き込みを分散できないか検討ください。

シャーディング構成ではそもそもこのようなインデックスに該当する概念がないので、Spanner特有の考慮事項となるでしょう。

### 負荷の管理

Spannerでは負荷の状況に応じてテーブルをスプリットに分割します。また分割したスプリットの担当ノードも動的に変更することで全体の負荷を平準化しようとします。
一時的に負荷のアンバランスが生じた場合も、自動的に負荷は平準化されます。
どのような不均一が発生したかは[Key Visualizer ](https://cloud.google.com/spanner/docs/key-visualizer?hl=ja)の[ヒートマップ](https://cloud.google.com/spanner/docs/key-visualizer/patterns?hl=ja)を見ることで確認が可能です。

基本的には自動調整機能に任せつつ全体で性能が不足した場合には、ノードを追加することが負荷管理の基本となります。ノードの追加・削除は無停止で可能です。
ただし、[単調に増加・減少するキー](https://cloud.google.com/spanner/docs/key-visualizer/patterns?hl=ja#monotonically_increasing_keys)についてはスキーマ設計での対応が必要となることもあります。

### 概念の対応

|シャーディングでの概念|Spannerでの概念|
|----|----|
|シャーディングキー|プライマリキー|
|各シャードへ配置したテーブル|インターリーブテーブル|
|各シャードへ配置したテーブルへのインデックス|インターリーブインデックス|
|全シャードへの網羅的な探索|全表探索か非インターリーブインデックスでの検索|
|各シャードのスケールアップ・ダウン|無停止でのノード追加・削除|

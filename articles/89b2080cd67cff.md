---
title: "シャーディング経験者に向けた Spanner のコンセプト解説"
emoji: "🔧"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["spanner", "gcp"]
published: false
---
## この記事の目的

リレーショナルデータベース（以下、RDBMS）を大規模に利用されるときの構成手法として、データベースシャーディング（Database sharding）という方法があります。オンラインゲームやSaaSなどアクセス頻度が高く、個別のユーザーの操作ごとの更新量が大きい用途などでデータベースの書き込み性の限界への回避策として多くの場面で利用されている手法です。

この手法について簡単に触れた後、この手法の経験者がSpannerを使う場合にシャーディングでの概念をどのようにSpannerに対応できるか解説します。

## シャーディングの構成

[シャーディング](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%A3%E3%83%BC%E3%83%89_(%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%83%BB%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3))は通常水平分割で実現されます。つまり1つのテーブルの行を複数の異なる物理データベースに配置します。このとき、どのカラムを基準にして分割するかを決めますが、このようなカラムをシャーディングキーと呼びます。よくあるケースではユーザーテーブルをシャーディング対象としたとき、ユーザー IDといったユーザーを一意に特定できるカラムを使って分散させます。マルチテナントのSaaSなどではテナントIDをシャーディングキーに使う場合もあるでしょう。

さらにあるレコードをどのシャードに格納するかを決める方法として、ハッシュ関数を適用してその結果を使う方式や、ユーザー IDとシャードの対応表を持つ方式などがあります。このドキュメントでは前者をハッシュ方式、後者を対応表方式と呼ぶことにします。
ハッシュ方式はロジック的にシャードが決定できるというメリットがありますが、運用開始をしてからの増設やシャーディングのやり直しがやや煩雑となります。
対応表方式は対応表を持つデータベースというコンポーネントが増えるものの、シャード増設が容易であると言ったメリットがあります。

![対応表方式でのシャーディング構成の図](/images/shard_concept.png)

対応表方式では実データへアクセスする前に対応表を一度引いてからアクセス先のシャードを確定し、実際のシャードにアクセスする動きとなります。

## シャーディングのメリット

### 書き込み性能上限の引き上げ

読み込み性能については読み取りレプリカを作ることで性能を引き上げる事が可能ですが、書き込み性能に関してはインスタンスサイズのスケールアップを行う必要がありました。シャーディングは書き込み先を複数の物理データベースに分散させることができるので、書き込み性能に関してもスケールアウトすることが可能です。

対応表方式ではアクセス毎にこの対応表を引くことになるため、それなりの性能が必要になります。幸い対応表は通常、頻繁に書き換えられることはないため、長いTTLで効率よくキャッシュすることが可能です。対応表のデータ構造は単純であるためmemcachedやRedisなどに書いて置くことも可能です。

## シャーディングのデメリット

### アプリケーション側の複雑さ

シャーディングされたデータベースへアクセスする部分でシャード決定する機構(シャードリゾルバ)が必要となります。一度書いてしまえば流用が可能ですが、バッチなど一部のアプリケーションが異なる言語で書かれている場合にはそれらの間で挙動を完全に一致させておくことが重要です。

対応表方式では毎回対応表へアクセスを行うとシャード全体と同じぐらいの高頻度のアクセスを受ける事となるため、前述の通りキャッシュすることが有効です。

### 構成管理の煩雑さ

一般的に各シャードは同一のテーブル構成で運用されます。そのため、シャーディング対象のデータベースに新しいテーブルやインデックスを追加するときに各シャードにDDLを漏れなく実行する必要があります。

### キャパシティ管理

各シャードの負荷が均一になっていると運用管理が楽ですが、現実問題としてはそのシャードに含まれるユーザー数を均一にしたとしてもサービスへのアクティビティが均一にならない（新規と初期ユーザーでアクティビティが異なるなど）こともあり個別で性能のキャパシティ管理が必要となります。

### シャードの増設・削除

サービス開始当初のシャード数では性能やストレージ容量が不足してきた場合には増設が必要になります。対応表方式では新規ユーザーを新シャードに登録するなどの工夫で増設することが可能でしょう。一方でハッシュ方式ではハッシュ関数にもよりますが、既存のユーザーのシャード移動が必要になる場合があります。これはかなり煩雑な対応が必要で、更新が行われないメンテナンス時間を設けてその間に実施するなどの工夫が必要です。

シャードの削除については廃止シャード上のユーザーのシャード間での移動が必要となるため、実際には廃止は行わず各シャードのスケールダウンで済ませる事が多いかもしれません。その場合、サービス全体のアクティビティが落ちてきたとしてもシャード数は維持する必要があります。

### シャードをまたいだ処理

シャーディングを導入した場合、複数のシャードが関連する処理は慎重に実装する必要があります。たとえば、ゲームであるユーザー（UserID AAAA、シャード1に所属）から別のユーザー（UserID BBBB、シャード3に所属）へアイテム（ItemId XXXX）を受け渡すような処理を考えます。この場合、

元ユーザー(AAAA)のシャード1に対して

```DELETE FROM item WHERE UserID=AAAA AND ItemId=XXXX```

贈り先ユーザー(BBBB)のシャード3に対して

```INSERT INTO item (UserID, ItemId, ... ) VALUES (BBBB, XXXX, ...)```

というDMLを発行することになるでしょう。各ユーザーは異なるシャード、つまり異なるデータベースに格納されている可能性があります。そのため、これらのDMLは2つの独立したトランザクションで発行されることになります。トランザクションがいずれも成功あるいは失敗した場合は問題ありませんが、一方のみが成功した場合にはアイテムがロストしたり増殖してしまいます。本来はこのような事態を避けるために[分散トランザクションの仕組み](https://dev.mysql.com/doc/refman/8.0/ja/xa.html)を使ってデータベース間で協調させる必要があります。

更新ではない場合でも、たとえばシャードをまたいだ検索処理を行いたい場合には全シャードをくまなく検索する必要があります。先の例のようにゲームのアイテムを想定すると、どのユーザーが所有しているか分からない特定のアイテムを全ユーザー検索したい場合などです。

## Spannerの自動シャーディング

Spannerは自動シャーディングという仕組みがあります。これは文字通り水平分割を自動的に行う機能です。シャーディングで使っていた分割の基準となるシャーディングキーとしては、プライマリキーを使います。

Spannerではテーブルはプライマリキーの辞書順でレイアウトされます。このレイアウトに対して、負荷の状況に応じて自動的にスプリットという単位へと分割を行います。個々のスプリットを異なるサーバーへ割り当てることで負荷を平準化とスケールを可能としています。

![Spannerでのシャードのイメージ](/images/spanner_shard.png)



### インターリーブテーブル

シャーディングでは分割の基準となるテーブル、たとえばユーザーテーブル以外のテーブルを各シャードに配置することがあります。具体的には、ゲームで各ユーザーが持っているアイテムのテーブルなどがこれに当たります。

### インターリーブインデックス

### 概念の対応

|シャーディングでの概念|Spannerでの概念|
|----|----|
|シャーディングキー|プライマリキー|
|各シャードのテーブル|インターリーブテーブル|
|各シャードのインデックス|インターリーブインデックス|
|全シャードへの網羅的な探索|全表探索か非インターリーブインデックスでの検索|
---
title: "フツーのデータベースとしてのSpanner"
emoji: "⚒️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["spanner","gcp"]
publication_name: "google_cloud_jp"
published: true
---
## この記事の目的

Spannerはスケーラビリティに優れたデータベースであると説明されることの多いデータベースです。スケーラビリティの面が強調された結果、「Spannerは何か特殊なデータベースではないか」「名前は聞いたことあるけど、普通のアプリケーションでは使えないんでしょ」というイメージを持たれていると感じています。その特性があるの事実ですが、テーブル定義とデータ型があり、トランザクションが実行可能で、SQLでクエリーや更新ないわば「普通のリレーショナルデータベース」としての側面もあります。

では実際にSpannerを普通のリレーショナルデータベース（以下、RDB）として使うと、MySQLやPostgreSQLとどこがどのように違うのか、どこを意識すればアプリケーションの移行が可能であるかという解説をしたいというのがこの記事の目的となります。

## 接続ライブラリ

Spannerはクライアントアプリケーションとの接続にgRPCを使います。これは既存のRDBとは異なるため、クライアントライブラリは専用のものが開発されています。対応プラットフォームは以下の通りです。

- C++
- C#
- Go
- Java
- Node.js
- PHP
- Python
- Ruby

クライアントライブラリはいわばSpannerへのネイティブの接続方法です。
ライブラリの使い方はさほど特殊でありませんが、Spannerに独自の概念を利用するために一般的なRDBのドライバーと少し違う部分もあります（たとえば、SQL以外での更新方法もサポートしているなど）。
新規のアプリケーションでSpannerのフル機能を活用されたい場合はこちらを使うことも検討いただきたいですが、一般的なRDBのドライバーに慣れておられる場合や既存のアプリケーションの移植では後述のドライバーを使う方が良い場合もあります。

クライアントライブラリとは別に[ドライバー](https://cloud.google.com/spanner/docs/drivers-overview)というものも提供されています。
クライアントライブラリがSpannerに接続するための専用のライブラリであるのに対して、ドライバーはクライアントライブラリを各言語向けのデータベースを扱うための汎用的な仕組みに沿うようにクライアントライブラリをラップしたものです。具体的にはたとえばJavaでのJDBCやGoの[database/sql](https://pkg.go.dev/database/sql)がそれにあたります。この仕組みに乗って操作していれば、データベースがMySQLやPostgreSQLでも多くの操作を共通した記述で行うことができるものです。

Goの`database/sql`を使っているアプリケーションをいくつか移植した感触としては、接続部分文字列など明らかに違う部分はあるもののそれ以外の部分は概ね手を付けなくても動作したという実感です。SQLレベルの互換性については、多くの場合はそのままで動作しましたが関数名など表記違いの箇所は書き換えが必要でした。

ORMなどもドライバーの一環として提供されています。たとえばJavaの[Hibernate](https://cloud.google.com/spanner/docs/use-hibernate)やRubyの[Active Record](https://cloud.google.com/spanner/docs/use-active-record)、Pythonの[SQLAlchemy](https://cloud.google.com/spanner/docs/use-sqlalchemy)などです。これらを使えば既存のアプリケーションの移植や他のデータベースへの操作と同じお作法でSpanner対応が可能です。

ドライバーは既存アプリケーションを移植するときには便利ですが、Spannerの独自機能などには対応していない場合もあります。各ドライバーとSpannerの機能の対応状況は[対応表](https://cloud.google.com/spanner/docs/drivers-overview#googlesql_drivers_and_orms)があります。

まとめると、まったく新規のアプリケーションの場合はクライアントライブラリを使うと良いですが、既存のアプリケーションの移植やノウハウがあるフレームワークやドライバーからの移行の場合はSpannerのドライバーが利用できます。

### PostgreSQL互換ドライバー

Spannerはアプリケーションとの間の通信をgRPCを使った独自プロトコルを使っていますが、これをPostgreSQLのワイヤプロトコルに変換する[PGAdapeter](https://cloud.google.com/spanner/docs/pgadapter)も提供されています。これを使えば、アプリケーションもPostgreSQLへの接続ドライバーをそのまま利用できますので、移植の手間がひとつ省略できます。

PGAdapterは独立したソフトウェアとして動作しますので、スタンドアロンとしても実行できますし、アプリケーションがコンテナで実行されている場合はPGAdapterをサイドカーとして実行されると良いでしょう。

## 認証

RDBへの接続にはIDとパスワードの組み合わせを利用されることが多いと思います。Spannerの場合は[IAMで認証と認可](https://cloud.google.com/spanner/docs/iam?hl=ja)を行います。

Spannerに限定される話ではありませんが、IAM認証ではサービスアカウントを使います。
固定のアクセスキーをファイルに記述して利用する方法は、漏洩のリスクやローテーションの問題があるため、[サービスカウント](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances?hl=ja)を利用すると良いです。実行環境がAWSやAzureだった場合には[Workload Identity連携](https://cloud.google.com/iam/docs/workload-identity-federation?hl=ja)を使うことで、やはり同様の仕組みは実現可能です。

クラウドでの認証方式に慣れておられないとIDとパスワードに比べて煩雑に感じられるかもしれませんが、IAMでの認証はクラウドのサービスを使う上では必要な認証になりますし、IAMとデータベースで二重管理にならずローテーションや漏洩のリスクを避ける手段が確立されているというメリットは大きいと思います。

## プライマリキー

ここが一番の違いかもしれません。Spannerには`AUTO INCREMENT`はありません。代替として[BIT_REVERSE関数](https://cloud.google.com/spanner/docs/reference/standard-sql/bit_functions#bit_reverse)というものがあります。

じゃあ、`AUTO INCREMENT`を使っているところはこれに書き換えればいいかと言うと、ちょっと待ってください。`AUTO INCREMENT`をプライマリキーとして使う場面の多くで必要なのは自動的に採番される単調増加し重複のない数字ではないでしょうか。このとき単調増加する、つまり追記順が保証されている必要がないのであれば、UUIDなど衝突のおそれが低い文字列を使うという方法もあります。[UUIDをデータベース側で自動生成する](https://zenn.dev/google_cloud_jp/articles/8bc8338a07f7b5#uuid-%E3%81%AE%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90)ことにより、重複がないという目的は達成することが可能です。

追記順が維持されている必要がある場合には、BIT_REVERSE関数が有効です。

プライマリキーとして単調増加する数値を使うべきではない理由は負荷の集中する箇所（ホットスポット）が発生し、それがインスタンス全体の性能のボトルネックになるためです。回避策としては単調増加して欲しい範囲が限定できるか検討する。たとえば、マルチテナントで各テナントの範囲内でのみ昇順・降順の並び替えが欲しいのであればインターリーブインデックスを作るという方法が考えられます。また、更新頻度が高くないのであれば極端に昇順・降順を忌避する必要はないかもしれません。たとえば、更新頻度が高くないマスタテーブルでは昇順のキーをつかっていたとしても性能のボトルネックとはならない事が多いためです。

## INSERT 〜 ON DUPLICATE KEY UPDATE

MySQLではINSERT時にすでに同じプライマリキーのレコードが存在した場合には更新を、なかったときには追記をするという[構文があります](https://dev.mysql.com/doc/refman/8.0/ja/insert-on-duplicate.html)。PostgreSQLではINSERTの[ON CONFLICT句](https://www.postgresql.jp/document/15/html/sql-insert.html#SQL-ON-CONFLICT)がそれにあたります。

この機能はSpannerでは[INSERT OR UPDATEという機能](https://zenn.dev/google_cloud_jp/articles/cfffd24b356f71)で実現が可能です。

## スケーラビリティ以外でのSpannerのメリット

### 可用性

Spannerはリージョナル構成で99.99%、マルチリージョンとデュアルリージョン構成で99.999%の可用性のSLAが提供されています。後述の通りメンテナンスウィンドウもないため、この可用性にはメンテナンスウィンドウを除くといった注釈もありません。

### メンテナンスの手間

Spannerには内部にコンピュートノードという概念がありますが、ノードへのメンテナンスダウンタイムはありません。コンピュートとストレージが分離されており、コンピュートは何らかの物理的実体の上で動作してしていますがそれぞれのコンポーネントは冗長構成となっているためコンピュートのメンテナンスが必要な場合もサービスに影響を与えることなく自動的に実行できるためです。

これはソフトウェアの更新に関しても同様です。ソフトウェアの更新は順次適用され、更新中にダウンタイムなども生じません。そのため、メンテナンスウィンドウの概念も存在しませんし、パッチ適用のためのサービス中断の調整なども必要ありません。

### Google Cloudの他サービスとの連携


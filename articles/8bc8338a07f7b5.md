---
title: "Cloud Spanner の自動生成主キーを使ってみる"
emoji: "🔑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cloudspanner"]
published: false
---
# はじめに
Cloud Spanner にシーケンスと UUID 生成機能が[実装されました](https://cloud.google.com/spanner/docs/release-notes?hl=ja#August_23_2023)。従来はアプリケーション側で主キーを生成して書き込む必要がありましたが、この機能によりデータベース側に任せる事ができるようになりました。

# シーケンスとは
MySQL では AUTO INCREMENT を使う事が多いため、シーケンス(SEQUENCE)に馴染みのない方もいらっしゃる可能性もあるためシーケンスについて軽く触れます。シーケンスとは一意の整数を生成することができるデータベースのオブジェクトです。

PostgreSQL では[CREATE SEQUENCE](https://www.postgresql.jp/document/15/html/sql-createsequence.html)で以下のように使います。
```sql
CREATE SEQUENCE serial;
```
のように予め作成しておき、nextval() 関数を呼ぶことで次の値が取り出せます。
```sql
SELECT nextval('serial');
```
nextval()をカラムのデフォルトとして指定することで、自動採番が可能となります。
# Cloud Spanner でのシーケンスの使い方
Cloud Spanner での使い方も基本的には同様です。

```sql
CREATE SEQUECE serial OPTIONS(sequence_kind='bit_reversed_positive');
```
で予め作っておき、GET_NEXT_SEQUENCE_VALUE() 関数で次の値が取得できます。
```sql
spanner> BEGIN;
Query OK, 0 rows affected (0.02 sec)

spanner(rw txn)> SELECT GET_NEXT_SEQUENCE_VALUE(SEQUENCE serial);
+---------------------+
|                     |
+---------------------+
| 6917529027641081856 |
+---------------------+
1 rows in set 
(65.76 msecs)
spanner(rw txn)> commit;
Query OK, 0 rows affected (0.02 sec)
```

いきなり大きな値が取れて面食らった方もいらっしゃるかと思いますが、こちらについては次節で説明します。
`CREATE SEQUECE` はいくつかオプションを取りますが、`sequence_kind` が必須のオプションで現時点で`bit_reversed_positive`が唯一とり得る値です。その他、開始する値なども指定可能です。他のデータベースから移行してきた場合など、既に一定の数値までレコードが入っている場合など、開始地点を大きめにしたいときにはこれらのオプションを指定ください。

シーケンスはそのまま使うことは少なく、実際にはカラムのデフォルトとして指定することが多いでしょう。その場合は、DDL に`DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE serial))`といった指定をすることで、無指定時にシーケンスから得た一意の値が自動的に入ります。
```sql
spanner> CREATE TABLE Users (
      ->   UserId INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE serial)),
      ->   FirstName  STRING(1024),
      ->   LastName   STRING(1024),
      -> ) PRIMARY KEY (UserId);
Query OK, 0 rows affected (11.96 sec)

spanner> INSERT INTO Users  (FirstName, LastName) VALUES ('Yamada', 'Taro');
Query OK, 1 rows affected (0.12 sec)

spanner> INSERT INTO Users  (FirstName, LastName) VALUES ('Tanaka', 'Satoko');
Query OK, 1 rows affected (0.32 sec)

spanner> SELECT UserId, BIT_REVERSE(UserId, true) AS Id, FirstName, LastName FROM Users ORDER BY Id;
+---------------------+----+-----------+----------+
| UserId              | Id | FirstName | LastName |
+---------------------+----+-----------+----------+
| 8070450532247928832 | 7  | Yamada    | Taro     |
| 2882303761517117440 | 10 | Tanaka    | Satoko   |
+---------------------+----+-----------+----------+
2 rows in set (8.65 msecs)
```
このように INSERT 時に無指定でも一意で順序性のある主キーが設定されます。
実際のアプリケーションから使う場合には、書き込んだレコードの主キーに何が割り当てられたのかを得る必要がありますので、その場合には INSERT 文の[THEN RETURN 構文](https://cloud.google.com/spanner/docs/reference/standard-sql/dml-syntax#insert_with_then_return)を使って書き込みの応答を得てください。

# BIT_REVERSE 関数
Cloud Spanner では主キーを使ってデータを分散させます。
そのため、主キーとして単調増加する値を使うと追記する箇所が常にデータの末尾に集中することになります。これは書き込みの性能についてスケーラビリティを阻害します。そのため、Cloud Spanner のシーケンスで連続値ではなくそれをビット順序反転した値を返します。この反転を行う関数が [BIT_REVERSE 関数](https://cloud.google.com/spanner/docs/reference/standard-sql/bit_functions#bit_reverse)です。

このセクションではこの関数の動作について解説しますが、*通常使う上ではその詳細まで把握している必要はありません*。

使用例
```sql
spanner> SELECT BIT_REVERSE(50, true) AS results;
+---------------------+
| results             |
+---------------------+
| 2738188573441261568 |
+---------------------+
1 rows in set (2.31 msecs)

spanner> SELECT BIT_REVERSE(51, false) AS results;
+----------------------+
| results              |
+----------------------+
| -3746994889972252672 |
+----------------------+
1 rows in set (2.37 msecs)
```
この例では入力として 50 と 51 を与えて、そのビット順序を反転した整数値を得ています。第二引数は入力された値の符号から変更しないフラグです。無効にして呼び出すと 51 のときのように正の値に対して負の値を返す場合があります(その逆に負の値で正の値を返す場合もあります)。主キーとして負の値が入っていることに特別な意味を持たせている場合などは、`true` を指定して常に正の値の範囲で使うと良いでしょう。

この関数がどのような変換を行っているかは入力と出力を2進数表記にするとわかりやすいです。
|10進数表記|2進数表記|
|--|--|
|50|0000000000000000000000000000000000000000000000000000000000110010|
|2738188573441261568|0010011000000000000000000000000000000000000000000000000000000000|
|51|0000000000000000000000000000000000000000000000000000000000110011|
|-3746994889972252672|1100110000000000000000000000000000000000000000000000000000000000|

符号を保存した場合には最上位ビット(MSB)が入力の符号と揃えられるためそこを除いて、入力の最下位ビット(LSB)からの並び順が出力の最上位ビットと同じであることが分かると思います。入力が1違うことで出力の最上位ビットが変わることになります。これによって、入力が続きの番号であっても出力は数値空間に対して広く分布します。

# シーケンスの主キーを使う上での注意点
シーケンスではビット順反転の値を返すため、この順によってソートすると意図した順序の結果が得られません。
また、値は一意となる結果を返しますが、1ずつ増える値ではなく飛び飛びの値となり、順序についても書き込み負荷の状況によっては入れ替わる可能性があります。

厳密な更新順でソートを行いたい場合は、[Commit タイムスタンプ](https://cloud.google.com/spanner/docs/commit-timestamp?hl=ja)のカラムを使うことをご検討ください。Commit タイムスタンプは True Time を使った時刻が記録されています。

# UUID の自動生成
従来より一意性のある主キーとして、UUIDv4 を使うことを推奨していました。今回のアップデートで [UUID の生成関数](https://cloud.google.com/spanner/docs/reference/standard-sql/functions-and-operators#generate_uuid)が新設され、それを[主キーのデフォルトに指定可能となりました](https://cloud.google.com/spanner/docs/primary-key-default-value#universally_unique_identifier_uuid)。

使用例
```sql
spanner> CREATE TABLE Fans (
      ->   FanId STRING(36) DEFAULT (GENERATE_UUID()),
      ->   Name STRING(MAX),
      -> ) PRIMARY KEY (FanId);     
Query OK, 0 rows affected (10.10 sec)

spanner> INSERT INTO Fans (Name) VALUES ('Mr. Kato');
Query OK, 1 rows affected (0.09 sec)

spanner> INSERT INTO Fans (Name) VALUES ('Hikaru Sulu');
Query OK, 1 rows affected (0.05 sec)

spanner> SELECT * FROM Fans;
+--------------------------------------+-------------+
| FanId                                | Name        |
+--------------------------------------+-------------+
| 7a629622-33fa-4aaa-b666-ef17b1febc47 | Mr. Kato    |
| f2497145-d9a9-469b-a259-ca1ab75c157a | Hikaru Sulu |
+--------------------------------------+-------------+
2 rows in set (7.72 msecs)
```

UUIDv4 は 122bit の空間にほぼ一様に分布します。これは一般な用途に対して十分に広い空間です。ドキュメントでは50％の確率で衝突が起こるまで毎秒10億個の ID を86年間生成を続ける必要があることが説明されています。通常の用途に対して十分に低い確率ではありますが、衝突以外の要因でも書き込みに失敗する可能性はあるため安全のためにアプリケーション側でのリトライ処理への考慮は引き続き推奨されます。

シーケンスのときと同様に書き込みを行った結果については [INSERT 文のTHEN RETURN](https://cloud.google.com/spanner/docs/primary-key-default-value#:~:text=INSERT%20with%20THEN%20RETURN)で得ることができます。

# まとめ
Cloud Spanner にシーケンスと UUID の自動生成機能が実装されました。これらを使うことでアプリケーション側で主キーを生成する必要がなくなりました。
いずれの機能も主キーが広く分布することについて配慮されていますので、書き込み性能のボトルネックとならないよう配慮されています。

---
title: "Cloud Spanner でのタグ付けのススメ"
emoji: "🏷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cloudspanner","spanner","gcp"]
published: false
---
# tl;dr

- Spanner でリクエストタグをつけておくとモニタリングのときに集約されるので便利
- タグは指定可能な長さに制限があるので命名に多少コツがあります

# 概要
Cloud Spanner ではトランザクションやリクエストにタグをつけることができます。

# タグの付け方

タグはリクエストの発行元がどのアプリケーションのどの部位から行われたかを特定する目的があります。そのため、アプリケーションのコンポーネントの名前や関数名などを付けて一意性を確保されると良いでしょう。ユーザーアクションを起因に実行される処理では、ユーザーアクションの名前をタグに含めるというのも有効です。

リクエストタグの付与例:
```ruby
client.execute(
  "SELECT SingerId, AlbumId, MarketingBudget FROM Albums",
  request_options: { tag: "app=concert,env=dev,action=select" }
).rows.each do |row|
  puts "#{row[:SingerId]} #{row[:AlbumId]} #{row[:MarketingBudget]}"
end
```

Spanner で利用可能な REPL である spanner-cli からも[タグを付けたトランザクションが実行](https://github.com/cloudspannerecosystem/spanner-cli#transaction-tags-and-request-tags)できます。テストなどにご利用ください

```
spanner> begin RW TAG tx1;
Query OK, 0 rows affected (0.02 sec)

spanner(rw txn)> select count(*) from counts;
+----------+
|          |
+----------+
| 31059600 |
+----------+
1 rows in set (56.05 secs)

spanner(rw txn)> commit;
Query OK, 0 rows affected (0.02 sec)
```
spanner-cli ではトランザクションについてタグを付けて実行したトランザクション内の個別のクエリーについて自動的に同じタグがリクエスに付与されます。
この動作は spanner-cli 特有の動作で、通常のクライアントドライバから実行される場合はトランザクションとリクエストは個別にタグを付与ください。

# タグの効果

Cloud Spanner では組み込みの統計テーブルが存在します。
MySQL での [performance_schema](https://dev.mysql.com/doc/refman/8.0/ja/performance-schema.html) や PostgreSQL の[統計情報ビュー](https://www.postgresql.jp/document/14/html/monitoring-stats.html#MONITORING-STATS-DYNAMIC-VIEWS-TABLE)に似た概念です。

この統計テーブルは集計時にタグに基づき CPU 使用率の上位のクエリなどを集計するため、どのタグがついているクエリーがより CPU 使用率を使っているかなどの調査が可能となります。
統計テーブルは SQL でアクセスが可能ですし、Query Insights というウェブコンソールの機能でもアクセスが可能です。対話的に問題を調査する際には Query Insights が便利です。

Query Insights はインスタンス全体の階層で見ると CPU 使用率がプロットされているのみです。注目したいデータベースを選択するとクエリー毎の負荷の推移などが見えます。

![Query Insightsでの上位N個のクエリとタグ](/images/query_insights.png)
この例では、4つのリクエストが上位に見えます。
タグがついているのは、上位の2つです。それぞれのリクエストについてグラフの表示範囲での実行回数や平均レイテンシ、平均スキャン行数などが集計されています。
この例では、`action=table_sampling` のタグがついている処理が非常に多くの行をスキャンしているため CPU 時間を使っている事がわかります。一方で`action=single_read` はスキャン行数と応答行数も1なので非常に単純なクエリーであることが分かりますが、実行回数が多い事がわかります。この場合、前者の方が負荷の面で課題であるため、スキャン行数の削減やキャッシュすることによる実行回数の削減を検討すれば負荷対策となるわけです。

Transaction Insights(コンソール上でのメニューではトランザクション分析情報)ではトランザクションの切り口で負荷の内訳が分析可能です。
![Transaction Insightsでのトランザクション毎の平均レイテンシ](/images/trx_insights.png)
この例では、2つのトランザクションが結果に現れています。
`action=update_singer_name` は平均レイテンシが大幅に大きいことが分かります。
また、トランザクション中で読み取り・書き込みを行ったテーブルとそのカラムについても集計されているため、トランザクションが想定通りの範囲のアクセスを行っているかの確認が行なえます。

Transaction Insights で見える2つのトランザクション中の SQL 個別にリクエストタグは付与していませんでしたが、それぞれ Query Insights 上で見える UPDATE か INSERT のみを行う処理でした。
Query Insights ではいずれも1回あたりのレイテンシ平均は 3.84ms と4.76ms と大きく違わないにも関わらず、トランザクションのレイテンシには大きな差があります。実際の処理の内容として、UPDATE は一つのトランザクションで 1000 行を行っていたためこのような差が生まれました。

# 注意点
## 長さの上限
タグに指定出来る文字列はは ASCII 文字のみで50文字までという[制限があります](https://cloud.google.com/spanner/docs/introspection/troubleshooting-with-tags?hl=ja#limitations)。

タグとしてソースコードのフルパスと行数などを指定すると制限を超過する場合があります。この長さ制限を超過すると切り詰められるため、リクエスト元を特定するという目的を達成できない可能性あるためご注意ください。

## 対応しているドライバ
Cloud Spanner へアクセスする方法はクライアントライブラリ、ORMとフレームワークドライバ、RPC API、REST APIの4通りあります。クライアントライブラリは Spanner 用に作られているだけあって[主な機能をすべて網羅しております](https://cloud.google.com/spanner/docs/api-libraries-overview?hl=ja#client-support)。

一方で、各言語の提供する DB アクセス共通化の仕組みやフレームワーク(例えば、Active Record や Hibernate など)で動作するドライバは[いくつかの機能制限があります](https://cloud.google.com/spanner/docs/drivers-overview?hl=ja#drivers_and_orms)。リクエストタグ付けについてはいくつかのフレームワークドライバでサポートされていません。

具体例として Go 言語の database/sql へのドライバはこの記事で紹介しているリクエストへのタグ付けにそのままでは対応しておりません。database/sql のドライバは Spanner クライアントライブラリへのラッパとして実装しているため、元のドライバインターフェイスで設定を指定することは[可能ですが](https://github.com/googleapis/go-sql-spanner/blob/main/docs/limitations.rst)、ややスマートさに欠けます。各ドライバでどのような制限があるか、回避策の有無などについてはドライバのマニュアルをご参照ください。

# 参考情報
- [リクエスト タグとトランザクション タグによるトラブルシューティング](https://cloud.google.com/spanner/docs/introspection/troubleshooting-with-tags?hl=ja)
